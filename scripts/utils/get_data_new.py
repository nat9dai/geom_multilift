# The reader to load the offline trajectory from files
# Last modified: 11-Aug-2025
# By: Yichao

import numpy as np
from casadi import *
import math

class DataLoader():
    """
    Class to load planned trajectory data from data files.
    """
    def __init__(self):
        self.num_drones = 6
        self.dt = 0.01  # 100Hz
        self.rl = 0.25
        self.alpha  = 2 * np.pi / self.num_drones
        self.cable_length = 1.0
        self.path = f'/home/carlson/ros2/multilift_ws/6quad_traj/Planning_plots_multiagent_meta_evaluation (rg_-003_-002_100Hz_6s_l=1m_large_dist_new_smooth_useThis)'
        # self.rg_task = np.load(f'{self.path}/trained_data_meta/rg_task.npy')    # the CoM offset of the payload
        self.ml = 1.50   # payload mass
        self.g = 9.81   # gravity
        self.train_idx = -1
        self.task_idx = 0
        self.ez = np.array([0,0,1]).reshape(3,1)
        # self.rg = np.hstack((self.rg_task, np.zeros((self.rg_task.shape[0],1)))) # payload-CoM offset
        
        # coefficients of the trajectory
        self.Coeffx = np.zeros((2,8))
        self.Coeffy = np.zeros((2,8))
        self.Coeffz = np.zeros((2,8))
        for k in range(2):
            self.Coeffx[k,:] = np.load(f'{self.path}/Reference_traj_6/coeffx'+str(k+1)+'.npy')  # TODO: change the path of 5s
            self.Coeffy[k,:] = np.load(f'{self.path}/Reference_traj_6/coeffy'+str(k+1)+'.npy')
            self.Coeffz[k,:] = np.load(f'{self.path}/Reference_traj_6/coeffz'+str(k+1)+'.npy')

        # payload trajectory 
        self.xl_train = np.load(f'{self.path}/xl_traj.npy', allow_pickle=True)
        segment_xl = self.xl_train   # shape (101, 13)
        print(f'xl shape{segment_xl.shape}')
        self.payload_x = segment_xl[:, 0:3]     # (101, 3) payload position
        self.payload_v = segment_xl[:, 3:6]     # (101, 3) payload velovity
        self.payload_q = segment_xl[:, 6:10]    # (101, 4) payload attitude quaternion
        self.payload_w = segment_xl[:, 10:13]   # (101, 3) payload angular velocity w

        # xc_train, the quadrotor and cable state from training
        self.xc_train = np.load(f'{self.path}/xq_traj.npy', allow_pickle=True)
        segment_xc = self.xc_train  # shape (6, 101, 7)
        # cable direction
        # self.cable_direction = np.load(f'Planning_plots_meta/cable_direction_{self.task_idx}.npy', allow_pickle=True)
        self.cable_direction = segment_xc[:, :, 0:3]  # (6, 101, 3) cable direction 
        # cable angular velocity omega
        self.cable_omega = segment_xc[:, :, 3:6]  # (6, 101, 3) cable angular velocity 
        # cable virtual force mu
        self.cable_mu = segment_xc[:, :, 6]  # (6, 101, 1) cable virtual force 

        # uc_train, the cable control
        self.uq_traj = np.load(f'{self.path}/uq_traj.npy', allow_pickle=True)
        self.cable_omega_dot = self.uq_traj[:, : , 0:3]  # shape (6, 100, 3) cable angular acceleration

        # DDP feedback gain
        segment_kb = np.load(f'{self.path}/Kfb_traj.npy', allow_pickle=True)
        self.Kb = segment_kb[ :, :, :]

        self.rg = np.array([0.02, -0.02, 0.0])

        # casadi symbolic variables
        self.polyc = SX.sym('c',1,8)
        self.time  = SX.sym('t')
        self.time0 = SX.sym('t0')  # initial time
        self.pl     = SX.sym('pl',3,1) # position of center-of-origin (CO) of the payload's body frame {Bl} in {I}
        self.vl     = SX.sym('vl',3,1) # velocity of CO in {Bl}
        self.ql     = SX.sym('ql',4,1) # quaternion of payload, its norm = 1
        self.wl     = SX.sym('wl',3,1) # angular velocity in {Bl}
        self.xl     = vertcat(self.pl, self.vl, self.ql, self.wl) # 13-by-1 vector
        self.nxl    = self.xl.numel()
        self.S_rg   = self.skew_sym(self.rg)   # skew-symmetric of payload-CoM offset
        self.Fl     = SX.sym('Fl',3,1) # total control force in {Bl}, generated by all the tension forces
        self.Ml     = SX.sym('Ml',3,1) # total control torque in {Bl}, generated by all the tension forces
        self.ul     = vertcat(self.Fl,self.Ml) # control wrench, 6-by-1 vector
        self.nul    = self.ul.numel()
        self.di     = SX.sym('di',3,1)   # cable direction in {I}, its norm = 1, pointing from the load to each quadrotor
        self.wi     = SX.sym('wi',3,1)   # cable angular velocity
        self.dwi    = SX.sym('dwi',3,1)  # cable angular acceleration
        self.ti     = SX.sym('ti',1)     # tension magnitude
        self.xi     = vertcat(self.di,self.wi,self.ti) # 7-by-1 vector
        self.nxi    = self.xi.numel()
        self.vi     = SX.sym('vi',1)     # tension magnitude 1st order time-derivative
        self.ui     = vertcat(self.dwi,self.vi) # cable control, 4-by-1 vector
        self.nui    = self.ui.numel()


    def get_drone_pos(self):
        self.drone_pos = np.zeros((self.num_drones, 3))  # Initialize drone positions
        for i in range(self.num_drones):
            ri = np.array([
                self.rl * math.cos(i * self.alpha),
                self.rl * math.sin(i * self.alpha),
                0.0
            ])  
            # Rl = self.quat_2_rot(self.payload_q[0])
            Rl = np.eye(3)
            self.drone_pos[i, :] = self.payload_x[0] + Rl @ ri + self.cable_length * self.cable_direction[i, 0, :].reshape(3, 1).T
        return self.drone_pos

    
    # Code below is from Dr. Bingheng
    def skew_sym(self, v): # skew-symmetric operator
        v_cross = vertcat(
            horzcat(0, -v[2], v[1]),
            horzcat(v[2], 0, -v[0]),
            horzcat(-v[1], v[0], 0)
        )
        return v_cross
    
    def quat_2_rot(self, q):
        q = np.asarray(q, dtype=float)
        w, x, y, z = q[..., 0], q[..., 1], q[..., 2], q[..., 3]
        R = np.empty(q.shape[:-1] + (3, 3))
        R[..., 0, 0] = 1 - 2 * (y**2 + z**2)
        R[..., 0, 1] = 2 * (x*y - z*w)
        R[..., 0, 2] = 2 * (x*z + y*w)
        R[..., 1, 0] = 2 * (x*y + z*w)
        R[..., 1, 1] = 1 - 2 * (x**2 + z**2)
        R[..., 1, 2] = 2 * (y*z - x*w)
        R[..., 2, 0] = 2 * (x*z - y*w)
        R[..., 2, 1] = 2 * (y*z + x*w)
        R[..., 2, 2] = 1 - 2 * (x**2 + y**2)
        return R

    # polynomial trajectories
    def polytraj(self,coeff,time,time0):
        time_vec   = vertcat(1,
                             self.time-self.time0,
                             (self.time-self.time0)**2,
                             (self.time-self.time0)**3,
                             (self.time-self.time0)**4,
                             (self.time-self.time0)**5,
                             (self.time-self.time0)**6,
                             (self.time-self.time0)**7)
        polyp      = mtimes(self.polyc, time_vec)
        polyp_fn   = Function('ref_p',[self.polyc,self.time,self.time0],[polyp],['pc0','t0','ti0'],['ref_pf'])
        ref_p      = polyp_fn(pc0=coeff,t0=time,ti0=time0)['ref_pf'].full()
        polyv      = jacobian(polyp, self.time)
        polyv_fn   = Function('ref_v',[self.polyc,self.time,self.time0],[polyv],['pc0','t0','ti0'],['ref_vf'])
        ref_v      = polyv_fn(pc0=coeff,t0=time,ti0=time0)['ref_vf'].full()
        polya      = jacobian(polyv, self.time)
        polya_fn   = Function('ref_a',[self.polyc,self.time,self.time0],[polya],['pc0','t0','ti0'],['ref_af'])
        ref_a      = polya_fn(pc0=coeff,t0=time,ti0=time0)['ref_af'].full()
        polyj      = jacobian(polya, self.time)
        polyj_fn   = Function('ref_j',[self.polyc,self.time,self.time0],[polyj],['pc0','t0','ti0'],['ref_jf'])
        ref_j      = polyj_fn(pc0=coeff,t0=time,ti0=time0)['ref_jf'].full()
        polys      = jacobian(polyj, self.time)
        polys_fn   = Function('ref_s',[self.polyc,self.time,self.time0],[polys],['pc0','t0','ti0'],['ref_sf'])
        ref_s      = polys_fn(pc0=coeff,t0=time,ti0=time0)['ref_sf'].full()
        return ref_p, ref_v, ref_a, ref_j, ref_s
    
    def minisnap_load_circle(self,Coeffx,Coeffy,Coeffz,time):
        t_switch = 0
        t1 = 3.0  # time to switch the trajectory, 2.4s for 4s traj
        if time <t1:
            ref_px, ref_vx, ref_ax, ref_jx, ref_sx = self.polytraj(Coeffx[0,:],time,t_switch)
            ref_py, ref_vy, ref_ay, ref_jy, ref_sy = self.polytraj(Coeffy[0,:],time,t_switch)
            ref_pz, ref_vz, ref_az, ref_jz, ref_sz = self.polytraj(Coeffz[0,:],time,t_switch)
        else:
            ref_px, ref_vx, ref_ax, ref_jx, ref_sx = self.polytraj(Coeffx[1,:],time,t1+t_switch)
            ref_py, ref_vy, ref_ay, ref_jy, ref_sy = self.polytraj(Coeffy[1,:],time,t1+t_switch)
            ref_pz, ref_vz, ref_az, ref_jz, ref_sz = self.polytraj(Coeffz[1,:],time,t1+t_switch)
        ref_p = np.reshape(np.vstack((ref_px, ref_py, ref_pz)), (3,1))
        ref_v = np.reshape(np.vstack((ref_vx, ref_vy, ref_vz)), (3,1))
        ref_q = np.array([[1,0,0,0]]).T
        ref_w = np.zeros((3,1))
        ref_xl= np.reshape(np.vstack((ref_p,ref_v,ref_q,ref_w)),self.nxl)
        ref_a = np.reshape(np.vstack((ref_ax, ref_ay, ref_az)), (3,1))
        ref_Fl= self.ml*(ref_a + self.g*self.ez) # reference force in world frame frame (Rl = identity matrix)
        ref_ml= self.S_rg@(self.ml*self.g*self.ez) # reference torque in the load's desired body frame
        ref_ul= np.reshape(np.vstack((ref_Fl,ref_ml)),self.nul)
        # state and control references of the cables
        alpha  = 2*np.pi/self.num_drones
        beta   = 4/9*np.pi # not needed to be collision-free
        ref_xq = np.zeros(int(self.num_drones)*self.nxi) # in the world frame
        ref_uq = np.zeros(int(self.num_drones)*self.nui)
        for i in range(int(self.num_drones)):
            ref_di   = np.array([[math.cos(beta)*math.cos(i*alpha),math.cos(beta)*math.sin(i*alpha),math.sin(beta)]]).T # reference direction vector
            ref_wi   = np.zeros((3,1))
            ref_ti   = np.array([[self.ml*self.g/self.num_drones]])
            ref_xi   = np.reshape(np.vstack((ref_di,ref_wi,ref_ti)),self.nxi)
            ref_xq[i*self.nxi:(i+1)*self.nxi] = ref_xi #np.reshape(ref_di,self.nxi)
        return ref_xl, ref_ul, ref_p, ref_xq, ref_uq


def main():
    # printout and test the data
    data_loader = DataLoader()
    print("payload_x:", data_loader.payload_x.shape)
    print("cable direction:", data_loader.cable_direction)
    drone_pos = data_loader.get_drone_pos()
    print("Drone positions:\n", drone_pos)
    print(f'feedback gain: {data_loader.Kb.shape}')
    


if __name__ == "__main__":
    main()